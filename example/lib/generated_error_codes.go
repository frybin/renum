// Code generated by renum v0.0.6-d5b9138 (github.com/gen0cide/renum) DO NOT EDIT.

package lib

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/gen0cide/renum"
)

// ErrorCode is a generated type alias for the ErrorCode enum.
// ErrorCode is an example error type that is used to demonstrate how renum's enum generator works.
type ErrorCode int

const (
	// ErrorCodeUndefinedEnumValue is an enum value for type ErrorCode.
	// ErrorCodeUndefinedEnumValue is the default value for enum type ErrorCode. It is meant to be a placeholder and default for unknown values.
	// This value is a default placeholder for any unknown type for the lib.ErrorCode enum.
	ErrorCodeUndefinedEnumValue ErrorCode = iota

	// ErrorCodeUnauthorized is an enum value for type ErrorCode.
	// Unauthorized is thrown when the request action cannot be taken.
	// Unauthorized is thrown to signify that the request was made by an *authenticated* requester, but that requester is not authorized to perform the requested action.
	ErrorCodeUnauthorized

	// ErrorCodeInvalidSQLQuery is an enum value for type ErrorCode.
	// InvalidSQLQuery is thrown when a user supplied SQL query is not valid.
	// INVALIDSQLQuery often means the caller should perform further validation in order to locate situations where they're taking unsanitized input from users and interpolating that value directly into the SQL query.
	ErrorCodeInvalidSQLQuery
)

var (
	// ErrUndefinedErrorCodeEnumValue is thrown when ParseErrorCode(s string) cannot locate a valid enum for the provided string.
	ErrUndefinedErrorCodeEnumValue = errors.New("cannot identify enum for provided value")
)

// ParseErrorCode attempts to convert a string identifier to it's corrasponding ErrorCode value, returning
// an error if it cannot match the string to a known enum value. This function supports multiple casings including:
// snake_case, PascalCase, camelCase, SCREAMING_CASE, and command-case. Generally, snake_case is the preferred method
// as most Marshalers will marshal to snake_case, and this function optimizes for it, but ParseErrorCode attempts to
// be flexible.
//
// In the event ParseErrorCode cannot identify a matching value, it will return the default ErrorCode value (0)
// along with an ErrUndefinedErrorCodeEnumValue error. This will also be the return should you provide either an empty
// string or a string that doesn't contain a valid UTF-8 alpha character as the first rune in the string. There are
// two exceptions to this rule:
//
//  * The string has leading is whitespace in which case ParseErrorCode will detect, trim, and attempt to parse the result.
//  * The string is an integer, in which case it will attempt to match the ErrorCode value for that corrasponding integer.
//
// If either of those options cannot subsequently locate a corrasponding enum value, it will return the default error
// behavior described above.
func ParseErrorCode(name string) (ErrorCode, error) {
	if len(name) < 1 {
		return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
	}

	first, _ := utf8.DecodeRuneInString(name)
	if first == utf8.RuneError {
		return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
	}

	switch {
	case unicode.IsLower(first):
		// test for snake_case
		if x, ok := _ErrorCodeValue[name]; ok {
			return x, nil
		}

		// test for command-case
		if x, ok := _ErrorCodeCommandValue[name]; ok {
			return x, nil
		}

		// test for camelCase
		if x, ok := _ErrorCodeCamelValue[name]; ok {
			return x, nil
		}
	case unicode.IsUpper(first):
		// test for PascalCase
		if x, ok := _ErrorCodePascalValue[name]; ok {
			return x, nil
		}

		// test for SCREAMING_CASE
		if x, ok := _ErrorCodeScreamingValue[name]; ok {
			return x, nil
		}
	case unicode.IsSpace(first):
		// the provided string had whitespace. Trim it and try again.
		return ParseErrorCode(strings.TrimSpace(name))
	case unicode.IsDigit(first):
		// the provided string started with a number - assuming this is
		// an integer and attempting to match it to a value.
		intVal, err := strconv.Atoi(name)
		if err != nil {
			return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
		}

		// use the Coder interface Lookup function to identify the integer value (if it exists).
		return LookupErrorCode(intVal)
	default:
		return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
	}

	return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
}

// LookupErrorCode attempts to convert a int to it's equivelent ErrorCode value.
func LookupErrorCode(id int) (ErrorCode, error) {
	if _, ok := _ErrorCodeMap[ErrorCode(id)]; ok {
		return ErrorCode(id), nil
	}

	return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
}

// Code implements the renum.Coder interface and allows an enum value to self report it's underlying integer ID. This
// primarily was intended to be able to support generic numeric types, but at this time, it's simply an int.
func (x ErrorCode) Code() int {
	return int(x)
}

const (
	_ErrorCodeNamespace = `github.com.gen0cide.renum.example.lib`
	_ErrorCodePkgName   = `lib`
	_ErrorCodePkgPath   = `github.com/gen0cide/renum/example/lib`
)

// Namespace implements renum.Namespacer interface.
func (x ErrorCode) Namespace() string {
	return _ErrorCodeNamespace
}

// PackageName returns the name of the parent package for this type.
func (x ErrorCode) PackageName() string {
	return _ErrorCodePkgName
}

// ImportPath returns the full import path of the parent package
func (x ErrorCode) ImportPath() string {
	return _ErrorCodePkgPath
}

const _ErrorCodeName = _ErrorCodeSnakeName

var _ErrorCodeValue = _ErrorCodeSnakeValue

var _ErrorCodeMap = _ErrorCodeSnakeMap

// String implements the Stringer interface.
func (x ErrorCode) String() string {
	if str, ok := _ErrorCodeMap[x]; ok {
		return str
	}

	return _ErrorCodeMap[ErrorCode(0)]
}

const _ErrorCodeSnakeName = "undefined_enum_valueunauthorizedinvalid_sql_query"

var _ErrorCodeSnakeValue = map[string]ErrorCode{
	_ErrorCodeSnakeName[0:20]:  0,
	_ErrorCodeSnakeName[20:32]: 1,
	_ErrorCodeSnakeName[32:49]: 2,
}

var _ErrorCodeSnakeMap = map[ErrorCode]string{
	0: _ErrorCodeSnakeName[0:20],
	1: _ErrorCodeSnakeName[20:32],
	2: _ErrorCodeSnakeName[32:49],
}

// SnakeCase returns the enum as a snake_case string.
func (x ErrorCode) SnakeCase() string {
	if str, ok := _ErrorCodeMap[x]; ok {
		return str
	}

	return _ErrorCodeMap[ErrorCode(0)]
}

const _ErrorCodeCommandName = "undefined-enum-valueunauthorizedinvalid-sql-query"

var _ErrorCodeCommandValue = map[string]ErrorCode{
	_ErrorCodeCommandName[0:20]:  0,
	_ErrorCodeCommandName[20:32]: 1,
	_ErrorCodeCommandName[32:49]: 2,
}

var _ErrorCodeCommandMap = map[ErrorCode]string{
	0: _ErrorCodeCommandName[0:20],
	1: _ErrorCodeCommandName[20:32],
	2: _ErrorCodeCommandName[32:49],
}

// CommandCase returns the enum as a command-case string.
func (x ErrorCode) CommandCase() string {
	if str, ok := _ErrorCodeCommandMap[x]; ok {
		return str
	}

	return _ErrorCodeCommandMap[ErrorCode(0)]
}

const _ErrorCodeScreamingName = "UNDEFINED_ENUM_VALUEUNAUTHORIZEDINVALID_SQL_QUERY"

var _ErrorCodeScreamingValue = map[string]ErrorCode{
	_ErrorCodeScreamingName[0:20]:  0,
	_ErrorCodeScreamingName[20:32]: 1,
	_ErrorCodeScreamingName[32:49]: 2,
}

var _ErrorCodeScreamingMap = map[ErrorCode]string{
	0: _ErrorCodeScreamingName[0:20],
	1: _ErrorCodeScreamingName[20:32],
	2: _ErrorCodeScreamingName[32:49],
}

// ScreamingCase returns the enum as a SCREAMING_CASE string.
func (x ErrorCode) ScreamingCase() string {
	if str, ok := _ErrorCodeScreamingMap[x]; ok {
		return str
	}

	return _ErrorCodeScreamingMap[ErrorCode(0)]
}

var _ErrorCodeKinds = map[ErrorCode]string{
	0: `lib.ErrorCodeUndefinedEnumValue`,
	1: `lib.ErrorCodeUnauthorized`,
	2: `lib.ErrorCodeInvalidSQLQuery`,
}

// Kind returns a string of the Go type for the given message.
func (x ErrorCode) Kind() string {
	if str, ok := _ErrorCodeKinds[x]; ok {
		return str
	}

	return _ErrorCodeKinds[ErrorCode(0)]
}

// Type implements the renum.Typer interface and allows the ErrorCode to self report the type of value it is.
func (x ErrorCode) Type() string {
	return "ErrorCode"
}

// PointerUnmarshal is used to enforce renum's Unmarshaler interface by doing compile-time checking
// that the ErrorCode type conforms with the right pointer receivers for Unmarshaler functions.
func (x ErrorCode) PointerUnmarshal() renum.Unmarshaler {
	return &x
}

const _ErrorCodePascalName = "UndefinedEnumValueUnauthorizedInvalidSQLQuery"

var _ErrorCodePascalValue = map[string]ErrorCode{
	_ErrorCodePascalName[0:18]:  0,
	_ErrorCodePascalName[18:30]: 1,
	_ErrorCodePascalName[30:45]: 2,
}

var _ErrorCodePascalMap = map[ErrorCode]string{
	0: _ErrorCodePascalName[0:18],
	1: _ErrorCodePascalName[18:30],
	2: _ErrorCodePascalName[30:45],
}

// PascalCase returns the enum as a PascalCase string.
func (x ErrorCode) PascalCase() string {
	if str, ok := _ErrorCodePascalMap[x]; ok {
		return str
	}

	return _ErrorCodePascalMap[ErrorCode(0)]
}

const _ErrorCodeCamelName = "undefinedEnumValueunauthorizedinvalidSQLQuery"

var _ErrorCodeCamelValue = map[string]ErrorCode{
	_ErrorCodeCamelName[0:18]:  0,
	_ErrorCodeCamelName[18:30]: 1,
	_ErrorCodeCamelName[30:45]: 2,
}

var _ErrorCodeCamelMap = map[ErrorCode]string{
	0: _ErrorCodeCamelName[0:18],
	1: _ErrorCodeCamelName[18:30],
	2: _ErrorCodeCamelName[30:45],
}

// CamelCase returns the enum as a cascalCase string.
func (x ErrorCode) CamelCase() string {
	if str, ok := _ErrorCodeCamelMap[x]; ok {
		return str
	}

	return _ErrorCodeCamelMap[ErrorCode(0)]
}

var _ErrorCodeSources = map[ErrorCode]string{
	0: `github.com/gen0cide/renum/example/lib.ErrorCodeUndefinedEnumValue`,
	1: `github.com/gen0cide/renum/example/lib.ErrorCodeUnauthorized`,
	2: `github.com/gen0cide/renum/example/lib.ErrorCodeInvalidSQLQuery`,
}

// Source returns an import path directly to the type.
func (x ErrorCode) Source() string {
	if str, ok := _ErrorCodeSources[x]; ok {
		return str
	}

	return _ErrorCodeSources[ErrorCode(0)]
}

var _ErrorCodeMessages = map[ErrorCode]string{
	0: `undefined enum value for type lib.ErrorCode`,
	1: `request was unauthorized`,
	2: `provided query was not valid sql`,
}

// Message returns the enum short message description.
func (x ErrorCode) Message() string {
	if str, ok := _ErrorCodeMessages[x]; ok {
		return str
	}

	return _ErrorCodeMessages[ErrorCode(0)]
}

var _ErrorCodeValueSlice = []ErrorCode{
	ErrorCodeUndefinedEnumValue,
	ErrorCodeUnauthorized,
	ErrorCodeInvalidSQLQuery,
}

// ErrorCodeValues returns a list of possible enum values for the ErrorCode type.
func ErrorCodeValues() []ErrorCode {
	tmp := make([]ErrorCode, len(_ErrorCodeValueSlice))
	copy(tmp, _ErrorCodeValueSlice)
	return tmp
}

var _ErrorCodeNames = []string{
	_ErrorCodeSnakeName[0:20],
	_ErrorCodeSnakeName[20:32],
	_ErrorCodeSnakeName[32:49],
}

// ErrorCodeNames returns a list of possible string values of ErrorCode.
func ErrorCodeNames() []string {
	tmp := make([]string, len(_ErrorCodeNames))
	copy(tmp, _ErrorCodeNames)
	return tmp
}

var _ErrorCodeDescriptions = map[ErrorCode]string{
	0: `This value is a default placeholder for any unknown type for the lib.ErrorCode enum.`,
	1: `Unauthorized is thrown to signify that the request was made by an *authenticated* requester, but that requester is not authorized to perform the requested action.`,
	2: `INVALIDSQLQuery often means the caller should perform further validation in order to locate situations where they're taking unsanitized input from users and interpolating that value directly into the SQL query.`,
}

// Description implements the emitter.Detailed interface.
func (x ErrorCode) Description() string {
	if str, ok := _ErrorCodeDescriptions[x]; ok {
		return str
	}

	return _ErrorCodeDescriptions[ErrorCode(0)]
}

var _ErrorCodeErrors = map[ErrorCode]string{
	0: `github.com.gen0cide.renum.example.lib.error_code_undefined_enum_value (0): undefined enum value for type lib.ErrorCode`,
	1: `github.com.gen0cide.renum.example.lib.error_code_unauthorized (1): request was unauthorized`,
	2: `github.com.gen0cide.renum.example.lib.error_code_invalid_sql_query (2): provided query was not valid sql`,
}

// Error implements the error interface.
func (x ErrorCode) Error() string {
	if str, ok := _ErrorCodeErrors[x]; ok {
		return str
	}

	return _ErrorCodeErrors[ErrorCode(0)]
}

var _ErrorCodePaths = map[ErrorCode]string{
	0: `github.com.gen0cide.renum.example.lib.error_code_undefined_enum_value`,
	1: `github.com.gen0cide.renum.example.lib.error_code_unauthorized`,
	2: `github.com.gen0cide.renum.example.lib.error_code_invalid_sql_query`,
}

// Source returns an import path directly to the type.
func (x ErrorCode) Path() string {
	if str, ok := _ErrorCodePaths[x]; ok {
		return str
	}

	return _ErrorCodePaths[ErrorCode(0)]
}

// MarshalText implements the encoding.TextMarshaler interface and allows ErrorCode values
// to be encoded to text, supporting any format that uses encoding.TextMarshaler under the hood.
func (x ErrorCode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface and allows ErrorCode values
// to be decoded from anything using this generic interface.
func (x *ErrorCode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseErrorCode(name)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalJSON implements the json.Marshaler interface.
func (x ErrorCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (x *ErrorCode) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshaling JSON value: %v", err)
	}

	tmp, err := ParseErrorCode(s)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface.
func (x ErrorCode) MarshalYAML() (interface{}, error) {
	return x.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface.
func (x *ErrorCode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return fmt.Errorf("error unmarshaling YAML value: %v", err)
	}

	tmp, err := ParseErrorCode(s)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// Scan implements the sql.Scanner interface and allows for translating database results into ErrorCode values.
// This does a best effort to match whatever might be returned (integer values, strings, or bytes) into a matching
// value, and follows the semantics of ParseErrorCode.
func (x *ErrorCode) Scan(value interface{}) error {
	var name string

	// handle the various types for the value that could be provided to us
	switch v := value.(type) {
	case string:
		name = v
	case []byte:
		name = string(v)
	case int8:
		name = strconv.FormatInt(int64(v), 10)
	case int16:
		name = strconv.FormatInt(int64(v), 10)
	case int32:
		name = strconv.FormatInt(int64(v), 10)
	case int:
		name = strconv.FormatInt(int64(v), 10)
	case int64:
		name = strconv.FormatInt(v, 10)
	case uint8:
		name = strconv.FormatUint(uint64(v), 10)
	case uint16:
		name = strconv.FormatUint(uint64(v), 10)
	case uint32:
		name = strconv.FormatUint(uint64(v), 10)
	case uint64:
		name = strconv.FormatUint(v, 10)
	case uint:
		name = strconv.FormatUint(uint64(v), 10)
	case nil:
		*x = ErrorCode(0)
		return nil
	case fmt.Stringer:
		name = v.String()
	default:
		return ErrUndefinedErrorCodeEnumValue
	}

	// try and lookup the the value
	tmp, err := ParseErrorCode(name)
	if err != nil {
		return err
	}

	// assign it to ourselves
	*x = tmp
	return nil
}

// Value implements the driver.Valuer interface to enable automatic conversion of renum.Enum values into
// database types. By default, this is done with as a snake_case string to support as many database
// implementations as possible. If you wish to optimize to integers or other types, implement a wrapper type.
func (x ErrorCode) Value() (driver.Value, error) {
	return x.String(), nil
}

// Set implements the Golang flag.Value interface and allows command line flags that are bound to ErrorCode types
// to automatically support string representations for value assignment. This follows the semantics of ParseErrorCode
// and thus can be flexible for how the string should be cased, etc. If an appropriate value cannot be identified,
// it will return an error.
func (x *ErrorCode) Set(val string) error {
	v, err := ParseErrorCode(val)
	if err != nil {
		return err
	}

	// all good, set the value!
	*x = v
	return nil
}

// Get implements the Golang flag.Getter interface and allows for the value of flag.Value to be retrieved
// by the flag package for various reasons.
func (x *ErrorCode) Get() interface{} {
	if x == nil {
		return nil
	}

	return *x
}
