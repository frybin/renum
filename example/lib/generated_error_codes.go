// Code generated by renum v0.0.8-970c1e6 (github.com/gen0cide/renum) DO NOT EDIT.

package lib

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

// ErrorCode is a generated type alias for the ErrorCode enum.
// ErrorCode is an example error type that is used to demonstrate how renum's enum generator works.
type ErrorCode int

const (
	// ErrorCodeUndefinedEnumValue is an enum value for type ErrorCode.
	// ErrorCodeUndefinedEnumValue is the default value for enum type ErrorCode. It is meant to be a place holder and default for unknown values.
	ErrorCodeUndefinedEnumValue ErrorCode = iota

	// ErrorCodeUnauthorized is an enum value for type ErrorCode.
	// Unauthorized is thrown when the request action cannot be taken.
	// Unauthorized is thrown to signify that the request was made by an *authenticated* requester, but that requester is not authorized to perform the requested action.
	ErrorCodeUnauthorized

	// ErrorCodeInvalidSQLQuery is an enum value for type ErrorCode.
	// InvalidSQLQuery is thrown when a user supplied SQL query is not valid.
	// InvalidSQLQuery often means the caller should perform further validation in order to locate situations where they're taking unsanitized input from users and interpolating that value directly into the SQL query.
	ErrorCodeInvalidSQLQuery
)

var (
	// ErrUndefinedErrorCodeEnumValue is thrown when ParseErrorCode(s string) cannot locate a valid enum for the provided string.
	ErrUndefinedErrorCodeEnumValue = errors.New("cannot identify enum for provided value")
)

// ParseErrorCode attempts to convert a string identifier to it's corrasponding ErrorCode value, returning
// an error if it cannot match the string to a known enum value. This function supports multiple casings including:
// snake_case, PascalCase, camelCase, SCREAMING_CASE, and command-case. Generally, snake_case is the preferred method
// as most Marshalers will marshal to snake_case, and this function optimizes for it, but ParseErrorCode attempts to
// be flexible.
//
// In the event ParseErrorCode cannot identify a matching value, it will return the default ErrorCode value (0)
// along with an ErrUndefinedErrorCodeEnumValue error. This will also be the return should you provide either an empty
// string or a string that doesn't contain a valid UTF-8 alpha character as the first rune in the string. There are
// two exceptions to this rule:
//
//  * The string has leading is whitespace in which case ParseErrorCode will detect, trim, and attempt to parse the result.
//  * The string is an integer, in which case it will attempt to match the ErrorCode value for that corrasponding integer.
//
// If either of those options cannot subsequently locate a corrasponding enum value, it will return the default error
// behavior described above.
func ParseErrorCode(name string) (ErrorCode, error) {
	if len(name) < 1 {
		return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
	}

	first, _ := utf8.DecodeRuneInString(name)
	if first == utf8.RuneError {
		return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
	}

	switch {
	case unicode.IsLower(first):
		// test for snake_case
		if x, ok := _ErrorCodeValue[name]; ok {
			return x, nil
		}
		// test for command-case
		if x, ok := _ErrorCodeCommandValue[name]; ok {
			return x, nil
		}
		// test for camelCase
		if x, ok := _ErrorCodeCamelValue[name]; ok {
			return x, nil
		}
		// test for dotted.case
		if x, ok := _ErrorCodeDottedValue[name]; ok {
			return x, nil
		}
	case unicode.IsUpper(first):
		// test for PascalCase
		if x, ok := _ErrorCodePascalValue[name]; ok {
			return x, nil
		}
		// test for SCREAMING_CASE
		if x, ok := _ErrorCodeScreamingValue[name]; ok {
			return x, nil
		}

		// test for SCREAMING_CASE
		if x, ok := _ErrorCodeTrainValue[name]; ok {
			return x, nil
		}
	case unicode.IsSpace(first):
		// the provided string had whitespace. Trim it and try again.
		return ParseErrorCode(strings.TrimSpace(name))
	case unicode.IsDigit(first):
		// the provided string started with a number - assuming this is
		// an integer and attempting to match it to a value.
		intVal, err := strconv.Atoi(name)
		if err != nil {
			return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
		}

		// use the Coder interface Lookup function to identify the integer value (if it exists).
		return LookupErrorCode(intVal)
	default:
		return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
	}

	return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
}

// LookupErrorCode attempts to convert a int to it's equivelent ErrorCode value.
func LookupErrorCode(id int) (ErrorCode, error) {
	if _, ok := _ErrorCodeMap[ErrorCode(id)]; ok {
		return ErrorCode(id), nil
	}

	return ErrorCode(0), ErrUndefinedErrorCodeEnumValue
}

// Code implements the renum.Coder interface and allows an enum value to self report it's underlying integer ID. This
// primarily was intended to be able to support generic numeric types, but at this time, it's simply an int.
// This method implements the github.com/gen0cide/renum.Coder interface.
func (x ErrorCode) Code() int {
	return int(x)
}

const _ErrorCodeName = _ErrorCodeSnakeName

var _ErrorCodeValue = _ErrorCodeSnakeValue

var _ErrorCodeMap = _ErrorCodeSnakeMap

// String implements the Stringer interface.
func (x ErrorCode) String() string {
	if str, ok := _ErrorCodeMap[x]; ok {
		return str
	}

	return _ErrorCodeMap[ErrorCode(0)]
}

const _ErrorCodeSnakeName = "undefined_enum_valueunauthorizedinvalid_sql_query"

var _ErrorCodeSnakeValue = map[string]ErrorCode{
	_ErrorCodeSnakeName[0:20]:  0,
	_ErrorCodeSnakeName[20:32]: 1,
	_ErrorCodeSnakeName[32:49]: 2,
}

var _ErrorCodeSnakeMap = map[ErrorCode]string{
	0: _ErrorCodeSnakeName[0:20],
	1: _ErrorCodeSnakeName[20:32],
	2: _ErrorCodeSnakeName[32:49],
}

// SnakeCase returns the enum as a snake_case string.
func (x ErrorCode) SnakeCase() string {
	if str, ok := _ErrorCodeMap[x]; ok {
		return str
	}

	return _ErrorCodeMap[ErrorCode(0)]
}

const _ErrorCodeCommandName = "undefined-enum-valueunauthorizedinvalid-sql-query"

var _ErrorCodeCommandValue = map[string]ErrorCode{
	_ErrorCodeCommandName[0:20]:  0,
	_ErrorCodeCommandName[20:32]: 1,
	_ErrorCodeCommandName[32:49]: 2,
}

var _ErrorCodeCommandMap = map[ErrorCode]string{
	0: _ErrorCodeCommandName[0:20],
	1: _ErrorCodeCommandName[20:32],
	2: _ErrorCodeCommandName[32:49],
}

// CommandCase returns the enum as a command-case string.
func (x ErrorCode) CommandCase() string {
	if str, ok := _ErrorCodeCommandMap[x]; ok {
		return str
	}

	return _ErrorCodeCommandMap[ErrorCode(0)]
}

const _ErrorCodeScreamingName = "UNDEFINED_ENUM_VALUEUNAUTHORIZEDINVALID_SQL_QUERY"

var _ErrorCodeScreamingValue = map[string]ErrorCode{
	_ErrorCodeScreamingName[0:20]:  0,
	_ErrorCodeScreamingName[20:32]: 1,
	_ErrorCodeScreamingName[32:49]: 2,
}

var _ErrorCodeScreamingMap = map[ErrorCode]string{
	0: _ErrorCodeScreamingName[0:20],
	1: _ErrorCodeScreamingName[20:32],
	2: _ErrorCodeScreamingName[32:49],
}

// ScreamingCase returns the enum as a SCREAMING_CASE string.
func (x ErrorCode) ScreamingCase() string {
	if str, ok := _ErrorCodeScreamingMap[x]; ok {
		return str
	}

	return _ErrorCodeScreamingMap[ErrorCode(0)]
}

// Type implements the renum.Typer interface and allows the ErrorCode to self report the type of value it is.
// This method implements the github.com/gen0cide/renum.Typer interface.
func (x ErrorCode) Type() string {
	return "ErrorCode"
}

const _ErrorCodePascalName = "UndefinedEnumValueUnauthorizedInvalidSQLQuery"

var _ErrorCodePascalValue = map[string]ErrorCode{
	_ErrorCodePascalName[0:18]:  0,
	_ErrorCodePascalName[18:30]: 1,
	_ErrorCodePascalName[30:45]: 2,
}

var _ErrorCodePascalMap = map[ErrorCode]string{
	0: _ErrorCodePascalName[0:18],
	1: _ErrorCodePascalName[18:30],
	2: _ErrorCodePascalName[30:45],
}

// PascalCase returns the enum as a PascalCase string.
func (x ErrorCode) PascalCase() string {
	if str, ok := _ErrorCodePascalMap[x]; ok {
		return str
	}

	return _ErrorCodePascalMap[ErrorCode(0)]
}

const _ErrorCodeCamelName = "undefinedEnumValueunauthorizedinvalidSQLQuery"

var _ErrorCodeCamelValue = map[string]ErrorCode{
	_ErrorCodeCamelName[0:18]:  0,
	_ErrorCodeCamelName[18:30]: 1,
	_ErrorCodeCamelName[30:45]: 2,
}

var _ErrorCodeCamelMap = map[ErrorCode]string{
	0: _ErrorCodeCamelName[0:18],
	1: _ErrorCodeCamelName[18:30],
	2: _ErrorCodeCamelName[30:45],
}

// CamelCase returns the enum value as a camelCase string.
func (x ErrorCode) CamelCase() string {
	if str, ok := _ErrorCodeCamelMap[x]; ok {
		return str
	}

	return _ErrorCodeCamelMap[ErrorCode(0)]
}

const _ErrorCodeDottedName = "undefined.enum.valueunauthorizedinvalid.sql.query"

var _ErrorCodeDottedValue = map[string]ErrorCode{
	_ErrorCodeDottedName[0:20]:  0,
	_ErrorCodeDottedName[20:32]: 1,
	_ErrorCodeDottedName[32:49]: 2,
}

var _ErrorCodeDottedMap = map[ErrorCode]string{
	0: _ErrorCodeDottedName[0:20],
	1: _ErrorCodeDottedName[20:32],
	2: _ErrorCodeDottedName[32:49],
}

// DottedCase returns the enum value as a dotted.case string.
func (x ErrorCode) DottedCase() string {
	if str, ok := _ErrorCodeDottedMap[x]; ok {
		return str
	}

	return _ErrorCodeDottedMap[ErrorCode(0)]
}

const _ErrorCodeTrainName = "UNDEFINED-ENUM-VALUEUNAUTHORIZEDINVALID-SQL-QUERY"

var _ErrorCodeTrainValue = map[string]ErrorCode{
	_ErrorCodeTrainName[0:20]:  0,
	_ErrorCodeTrainName[20:32]: 1,
	_ErrorCodeTrainName[32:49]: 2,
}

var _ErrorCodeTrainMap = map[ErrorCode]string{
	0: _ErrorCodeTrainName[0:20],
	1: _ErrorCodeTrainName[20:32],
	2: _ErrorCodeTrainName[32:49],
}

// TrainCase returns the enum value as a TRAIN-CASE string.
func (x ErrorCode) TrainCase() string {
	if str, ok := _ErrorCodeTrainMap[x]; ok {
		return str
	}

	return _ErrorCodeTrainMap[ErrorCode(0)]
}

const (
	_ErrorCodePkgName = `lib`
	_ErrorCodePkgPath = `github.com/gen0cide/renum/example/lib`
)

// PackageName returns the name of the parent package for the ErrorCode type as
// part of the github.com/gen0cide/renum.Sourcer interface.
func (x ErrorCode) PackageName() string {
	return _ErrorCodePkgName
}

// ImportPath returns the full import path of the parent package for the ErrorCode
// type as part of the github.com/gen0cide/renum.Sourcer interface.
func (x ErrorCode) PackagePath() string {
	return _ErrorCodePkgPath
}

var _ErrorCodeExportRefs = map[ErrorCode]string{
	0: `github.com/gen0cide/renum/example/lib.ErrorCodeUndefinedEnumValue`,
	1: `github.com/gen0cide/renum/example/lib.ErrorCodeUnauthorized`,
	2: `github.com/gen0cide/renum/example/lib.ErrorCodeInvalidSQLQuery`,
}

// ExportRef returns the full Go import path for the parent package of ErrorCode
// joined with the exported name for the enum value. This is part of the github.com/gen0cide/renum.Sourcer interface.
func (x ErrorCode) ExportRef() string {
	if str, ok := _ErrorCodeExportRefs[x]; ok {
		return str
	}

	return _ErrorCodeExportRefs[ErrorCode(0)]
}

var _ErrorCodeExportTypes = map[ErrorCode]string{
	0: `lib.ErrorCodeUndefinedEnumValue`,
	1: `lib.ErrorCodeUnauthorized`,
	2: `lib.ErrorCodeInvalidSQLQuery`,
}

// ExportType returns package name the parent package of ErrorCode joined with the
// exported name for the enum value. This is part of the github.com/gen0cide/renum.Sourcer interface.
func (x ErrorCode) ExportType() string {
	if str, ok := _ErrorCodeExportTypes[x]; ok {
		return str
	}

	return _ErrorCodeExportTypes[ErrorCode(0)]
}

var _ErrorCodeMessages = map[ErrorCode]string{
	0: `undefined enum value for type lib.ErrorCode`,
	1: `request was unauthorized`,
	2: `provided query was not valid sql`,
}

// Message returns the enum short message description.
func (x ErrorCode) Message() string {
	if str, ok := _ErrorCodeMessages[x]; ok {
		return str
	}

	return _ErrorCodeMessages[ErrorCode(0)]
}

var _ErrorCodeValueSlice = []ErrorCode{
	ErrorCodeUndefinedEnumValue,
	ErrorCodeUnauthorized,
	ErrorCodeInvalidSQLQuery,
}

// ErrorCodeValues returns a list of possible enum values for the ErrorCode type.
func ErrorCodeValues() []ErrorCode {
	tmp := make([]ErrorCode, len(_ErrorCodeValueSlice))
	copy(tmp, _ErrorCodeValueSlice)
	return tmp
}

var _ErrorCodeNames = []string{
	_ErrorCodeSnakeName[0:20],
	_ErrorCodeSnakeName[20:32],
	_ErrorCodeSnakeName[32:49],
}

// ErrorCodeNames returns a list of possible string values of ErrorCode.
func ErrorCodeNames() []string {
	tmp := make([]string, len(_ErrorCodeNames))
	copy(tmp, _ErrorCodeNames)
	return tmp
}

var _ErrorCodeDescriptions = map[ErrorCode]string{
	0: `ErrorCodeUndefinedEnumValue is the default value for enum type ErrorCode. It is meant to be a place holder and default for unknown values.`,
	1: `Unauthorized is thrown to signify that the request was made by an *authenticated* requester, but that requester is not authorized to perform the requested action.`,
	2: `InvalidSQLQuery often means the caller should perform further validation in order to locate situations where they're taking unsanitized input from users and interpolating that value directly into the SQL query.`,
}

// Description allows a caller to retrieve more detailed description information
// about an enum value. This information is not passed around with the enum, but kept
// inside the source package and retrieved with this method. This method implements
// the github.com/gen0cide/renum.Descriptioner interface.
func (x ErrorCode) Description() string {
	if str, ok := _ErrorCodeDescriptions[x]; ok {
		return str
	}

	return _ErrorCodeDescriptions[ErrorCode(0)]
}

var _ErrorCodeErrors = map[ErrorCode]string{
	0: `github.com.gen0cide.renum.example.lib.error_code_undefined_enum_value (0): undefined enum value for type lib.ErrorCode`,
	1: `github.com.gen0cide.renum.example.lib.error_code_unauthorized (1): request was unauthorized`,
	2: `github.com.gen0cide.renum.example.lib.error_code_invalid_sql_query (2): provided query was not valid sql`,
}

// Error implements the error interface.
func (x ErrorCode) Error() string {
	if str, ok := _ErrorCodeErrors[x]; ok {
		return str
	}

	return _ErrorCodeErrors[ErrorCode(0)]
}

const (
	_ErrorCodeNamespace = `github.com.gen0cide.renum.example.lib`
)

// Namespace returns the a dotted namespace representation of the Go package import
// path for the parent package to ErrorCode. This method implements the github.com/gen0cide/renum.Namespacer interface.
func (x ErrorCode) Namespace() string {
	return _ErrorCodeNamespace
}

var _ErrorCodePaths = map[ErrorCode]string{
	0: `github.com.gen0cide.renum.example.lib.error_code_undefined_enum_value`,
	1: `github.com.gen0cide.renum.example.lib.error_code_unauthorized`,
	2: `github.com.gen0cide.renum.example.lib.error_code_invalid_sql_query`,
}

// Paths returns a full "path" comprised of namespace + id for a given enum value. This
// method implements the github.com/gen0cide/renum.Namespacer interface.
func (x ErrorCode) Path() string {
	if str, ok := _ErrorCodePaths[x]; ok {
		return str
	}

	return _ErrorCodePaths[ErrorCode(0)]
}

var _ErrorCodeIDs = map[ErrorCode]string{
	0: `error_code_undefined_enum_value`,
	1: `error_code_unauthorized`,
	2: `error_code_invalid_sql_query`,
}

// ID returns a snake_case identifier comprised of the enum's standard snake_case prefixed
// with the ErrorCode's snake_case name. This method implements the github.com/gen0cide/renum.Namespacer interface.
func (x ErrorCode) ID() string {
	if str, ok := _ErrorCodeIDs[x]; ok {
		return str
	}

	return _ErrorCodeIDs[ErrorCode(0)]
}

// Name returns a snake case identifier comprised of the enum's actual identifier. This name essentially is an alias
// to the String() function.
func (x ErrorCode) Name() string {
	return x.String()
}

// MarshalText implements the encoding.TextMarshaler interface and allows ErrorCode values
// to be encoded to text, supporting any format that uses encoding.TextMarshaler under the hood.
func (x ErrorCode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface and allows ErrorCode values
// to be decoded from anything using this generic interface.
func (x *ErrorCode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseErrorCode(name)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalJSON implements the json.Marshaler interface.
func (x ErrorCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (x *ErrorCode) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshaling JSON value: %v", err)
	}

	tmp, err := ParseErrorCode(s)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalCSV implements the csvutil.Marshaler interface. (https://godoc.org/github.com/jszwec/csvutil#Marshaler)
func (x ErrorCode) MarshalCSV() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalCSV implements the csvutil.Unmarshaler interface. (https://godoc.org/github.com/jszwec/csvutil#Unmarshaler)
func (x *ErrorCode) UnmarshalCSV(b []byte) error {
	tmp, err := ParseErrorCode(string(b))
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface.
func (x ErrorCode) MarshalYAML() (interface{}, error) {
	return x.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface.
func (x *ErrorCode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return fmt.Errorf("error unmarshaling YAML value: %v", err)
	}

	tmp, err := ParseErrorCode(s)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// Scan implements the sql.Scanner interface and allows for translating database results into ErrorCode values.
// This does a best effort to match whatever might be returned (integer values, strings, or bytes) into a matching
// value, and follows the semantics of ParseErrorCode.
func (x *ErrorCode) Scan(value interface{}) error {
	var name string

	// handle the various types for the value that could be provided to us
	switch v := value.(type) {
	case string:
		name = v
	case []byte:
		name = string(v)
	case int8:
		name = strconv.FormatInt(int64(v), 10)
	case int16:
		name = strconv.FormatInt(int64(v), 10)
	case int32:
		name = strconv.FormatInt(int64(v), 10)
	case int:
		name = strconv.FormatInt(int64(v), 10)
	case int64:
		name = strconv.FormatInt(v, 10)
	case uint8:
		name = strconv.FormatUint(uint64(v), 10)
	case uint16:
		name = strconv.FormatUint(uint64(v), 10)
	case uint32:
		name = strconv.FormatUint(uint64(v), 10)
	case uint64:
		name = strconv.FormatUint(v, 10)
	case uint:
		name = strconv.FormatUint(uint64(v), 10)
	case nil:
		*x = ErrorCode(0)
		return nil
	case fmt.Stringer:
		name = v.String()
	default:
		return ErrUndefinedErrorCodeEnumValue
	}

	// try and lookup the the value
	tmp, err := ParseErrorCode(name)
	if err != nil {
		return err
	}

	// assign it to ourselves
	*x = tmp
	return nil
}

// Value implements the driver.Valuer interface to enable automatic conversion of renum.Enum values into
// database types. By default, this is done with as a snake_case string to support as many database
// implementations as possible. If you wish to optimize to integers or other types, implement a wrapper type.
func (x ErrorCode) Value() (driver.Value, error) {
	return x.String(), nil
}

// Set implements the Golang flag.Value interface and allows command line flags that are bound to ErrorCode types
// to automatically support string representations for value assignment. This follows the semantics of ParseErrorCode
// and thus can be flexible for how the string should be cased, etc. If an appropriate value cannot be identified,
// it will return an error.
func (x *ErrorCode) Set(val string) error {
	v, err := ParseErrorCode(val)
	if err != nil {
		return err
	}

	// all good, set the value!
	*x = v
	return nil
}

// Get implements the Golang flag.Getter interface and allows for the value of flag.Value to be retrieved
// by the flag package for various reasons.
func (x *ErrorCode) Get() interface{} {
	if x == nil {
		return nil
	}

	return *x
}
