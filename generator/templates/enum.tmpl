{{- define "header"}}
// Code generated by renum (github.com/gen0cide/renum)
// DO NOT EDIT!

package {{.package}}

import (
		"errors"
    "fmt"
		"unicode"
		"unicode/utf8"
)
{{end -}}

{{- define "definition"}}
// {{.config.EnumID}} is a generated type alias for the {{.config.EnumID}} enum.
type {{.config.EnumID}} {{.config.Go.Type}}
{{- end }}

{{- define "enum"}}
const (
{{- $enumName := .config.EnumID -}}
{{- $vars := dict "lastoffset" 0 -}}
{{ range $rIndex, $value := .config.Values }}
	{{- $lastOffset := pluck "lastoffset" $vars | first }}{{ $offset := sub $value.Value $rIndex }}
	{{ if eq $value.Pascal "_"}}// Skipped value{{else}}// {{$value.PrefixedPascal}} is an enum value for type {{$enumName}}.{{end}}
	{{- if $value.Comment}}
	// {{$value.Comment}}
	{{- end}}
	{{- if $value.Description}}
	// {{$value.Description}}
	{{- end}}
  {{$value.PrefixedPascal}} {{ if eq $rIndex 0 }}{{$enumName}} = iota{{ if ne 0 $offset }} + {{ $offset }}{{end}}{{else if ne $lastOffset $offset }}{{$enumName}} = iota + {{ $offset }}{{end}}{{$_ := set $vars "lastoffset" $offset}}

{{ end}}
  {{ if .config.Plugins.Namespace.Enabled }}
  _{{.config.EnumID}}Namespace = `{{.config.Plugins.Namespace.Namespace}}`
  {{- end }}
	_{{.config.EnumID}}PkgName = `{{.config.Go.PackageName}}`
	_{{.config.EnumID}}PkgPath = `{{.config.Go.PackagePath}}`
)

var (
	// ErrUndefined{{.config.EnumID}}EnumValue is thrown when Parse{{.config.EnumID}}(s string) cannot locate a valid enum for the provided string.
	ErrUndefined{{.config.EnumID}}EnumValue = errors.New("cannot identify enum for provided value")
)

{{ template "stringer" . }}

// Parse{{.config.EnumID}} attempts to convert a string to a {{.config.EnumID}}
func Parse{{.config.EnumID}}(name string) ({{.config.EnumID}}, error) {
	if len(name) < 1 {
		return {{.config.EnumID}}(0), ErrUndefined{{.config.EnumID}}EnumValue
	}

	first, _ := utf8.DecodeRuneInString(name)
	if first == utf8.RuneError {
		return {{.config.EnumID}}(0), ErrUndefined{{.config.EnumID}}EnumValue
	}

	switch {
	case unicode.IsLower(first):
		// test for snake_case
		if x, ok := _{{.config.EnumID}}Value[name]; ok {
			return x, nil
		}

		// test for command-case
		if x, ok := _{{.config.EnumID}}CommandValue[name]; ok {
			return x, nil
		}

		// test for camelCase
		if x, ok := _{{.config.EnumID}}CamelValue[name]; ok {
			return x, nil
		}
	case unicode.IsUpper(first):
		// test for PascalCase
		if x, ok := _{{.config.EnumID}}PascalValue[name]; ok {
			return x, nil
		}

		// test for SCREAMING_CASE
		if x, ok := _{{.config.EnumID}}ScreamingValue[name]; ok {
			return x, nil
		}
	default:
		return {{.config.EnumID}}(0), ErrUndefined{{.config.EnumID}}EnumValue
	}

	return {{.config.EnumID}}(0), ErrUndefined{{.config.EnumID}}EnumValue
}

{{ if .config.Plugins.Text }}
// MarshalText implements the text marshaller method
func (x {{.config.EnumID}}) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *{{.config.EnumID}}) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := Parse{{.config.EnumID}}(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
{{end}}

{{ if .config.Plugins.SQL }}
// Scan implements the Scanner interface.
func (x *{{.config.EnumID}}) Scan(value interface{}) error {
	var name string

	switch v := value.(type) {
	case string:
		name = v
	case []byte:
		name = string(v)
	case nil:
		*x = {{.config.EnumID}}(0)
		return nil
	}

	tmp, err := Parse{{.config.EnumID}}(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// Value implements the driver Valuer interface.
func (x {{.config.EnumID}}) Value() (driver.Value, error) {
	return x.String(), nil
}
{{end}}

{{ if .config.Plugins.Flags }}
// Set implements the Golang flag.Value interface func.
func (x *{{.config.EnumID}}) Set(val string) error {
	v, err := Parse{{.config.EnumID}}(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *{{.config.EnumID}}) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *{{.config.EnumID}}) Type() string {
	return "{{.config.EnumID}}"
}
{{end}}

{{ if .config.Plugins.Codes.Simple }}
// Lookup{{.config.EnumID}} attempts to convert a {{.config.Go.Type}} to it's equivelent {{.config.EnumID}} value.
func Lookup{{.config.EnumID}}(id {{.config.Go.Type}}) ({{.config.EnumID}}, error) {
	if _, ok := _{{.config.EnumID}}Map[{{.config.EnumID}}(id)]; ok {
		return {{.config.EnumID}}(id), nil
	}
	{{if .names -}}
	return {{.config.EnumID}}(0), fmt.Errorf("%T(%v) is not a valid {{.config.EnumID}}, try [%s]", id, id, strings.Join(_{{.config.EnumID}}Names, ", "))
	{{- else -}}
	return {{.config.EnumID}}(0), fmt.Errorf("%T(%v) is not a valid {{.config.EnumID}}", id, id)
	{{- end}}
}

// Code implements the Coder interface.
func (x {{.config.EnumID}}) Code() int {
  return int(x)
}
{{end}}

{{ if .config.Plugins.JSON }}
// MarshalJSON implements the json.Marshaler interface.
func (x {{.config.EnumID}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (x *{{.config.EnumID}}) UnmarshalJSON(b []byte) error {
	var s string
  if err := json.Unmarshal(b, &s); err != nil {
    return fmt.Errorf("error unmarshaling JSON value: %v", err)
  }
	tmp, err := Parse{{.config.EnumID}}(s)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
{{end}}

{{ if .config.Plugins.YAML }}
// MarshalYAML implements the yaml.Marshaler interface.
func (x {{.config.EnumID}}) MarshalYAML() (interface{}, error) {
	return x.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface.
func (x *{{.config.EnumID}}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
  if err := unmarshal(&s); err != nil {
    return fmt.Errorf("error unmarshaling YAML value: %v", err)
  }

	tmp, err := Parse{{.config.EnumID}}(s)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
{{end}}
{{end}}


{{- define "stringer"}}
const _{{.config.EnumID}}Name = "{{ stringify_underscore .config }}"

const _{{.config.EnumID}}PascalName = "{{ stringify_pascal .config }}"

const _{{.config.EnumID}}CamelName = "{{ stringify_camel .config }}"

const _{{.config.EnumID}}ScreamingName = "{{ stringify_screaming .config }}"

const _{{.config.EnumID}}CommandName = "{{ stringify_command .config }}"

{{ if .names }}var _{{.config.EnumID}}Names = {{namify .config}}

// {{.config.EnumID}}Names returns a list of possible string values of {{.config.EnumID}}.
func {{.config.EnumID}}Names() []string {
	tmp := make([]string, len(_{{.config.EnumID}}Names))
	copy(tmp, _{{.config.EnumID}}Names)
	return tmp
}

var _{{.config.EnumID}}ValueSlice = {{ valueify .config }}

// {{.config.EnumID}}Values returns a list of possible enum values for the {{.config.EnumID}} type.
func {{.config.EnumID}}Values() []{{.config.EnumID}} {
	tmp := make([]{{.config.EnumID}}, len(_{{.config.EnumID}}ValueSlice))
	copy(tmp, _{{.config.EnumID}}ValueSlice)
	return tmp
}
{{ end -}}

var _{{.config.EnumID}}Value = {{ unmapify .config .lowercase }}

var _{{.config.EnumID}}PascalValue = {{ unmapify_pascal .config }}

var _{{.config.EnumID}}CamelValue = {{ unmapify_camel .config }}

var _{{.config.EnumID}}ScreamingValue = {{ unmapify_screaming .config }}

var _{{.config.EnumID}}CommandValue = {{ unmapify_command .config }}

var _{{.config.EnumID}}Map = {{ mapify .config }}

var _{{.config.EnumID}}PascalMap = {{ mapify_pascal .config }}

var _{{.config.EnumID}}CamelMap = {{ mapify_camel .config }}

var _{{.config.EnumID}}ScreamingMap = {{ mapify_screaming .config }}

var _{{.config.EnumID}}CommandMap = {{ mapify_command .config }}

// String implements the Stringer interface.
func (x {{.config.EnumID}}) String() string {
	if str, ok := _{{.config.EnumID}}Map[x]; ok {
		return str
	}

	return _{{.config.EnumID}}Map[{{.config.EnumID}}(0)]
}

// PascalCase returns the enum as a PascalCase string.
func (x {{.config.EnumID}}) PascalCase() string {
	if str, ok := _{{.config.EnumID}}PascalMap[x]; ok {
		return str
	}

	return _{{.config.EnumID}}PascalMap[{{.config.EnumID}}(0)]
}

// CamelCase returns the enum as a cascalCase string.
func (x {{.config.EnumID}}) CamelCase() string {
	if str, ok := _{{.config.EnumID}}CamelMap[x]; ok {
		return str
	}

	return _{{.config.EnumID}}CamelMap[{{.config.EnumID}}(0)]
}

// ScreamingCase returns the enum as a SCREAMING_CASE string.
func (x {{.config.EnumID}}) ScreamingCase() string {
	if str, ok := _{{.config.EnumID}}ScreamingMap[x]; ok {
		return str
	}

	return _{{.config.EnumID}}ScreamingMap[{{.config.EnumID}}(0)]
}

// CommandCase returns the enum as a SCREAMING_CASE string.
func (x {{.config.EnumID}}) CommandCase() string {
	if str, ok := _{{.config.EnumID}}CommandMap[x]; ok {
		return str
	}

	return _{{.config.EnumID}}CommandMap[{{.config.EnumID}}(0)]
}

var _{{.config.EnumID}}Kinds = {{ mapify_kinds .config }}

// Kind returns a string of the Go type for the given message.
func (x {{.config.EnumID}}) Kind() string {
  if str, ok := _{{.config.EnumID}}Kinds[x]; ok {
    return str
  }

  return _{{.config.EnumID}}Kinds[{{.config.EnumID}}(0)]
}

var _{{.config.EnumID}}Sources = {{ mapify_full_kinds .config }}

// Source returns an import path directly to the type.
func (x {{.config.EnumID}}) Source() string {
  if str, ok := _{{.config.EnumID}}Sources[x]; ok {
    return str
  }

  return _{{.config.EnumID}}Sources[{{.config.EnumID}}(0)]
}

var _{{.config.EnumID}}Paths = {{ mapify_full_paths .config }}

// Source returns an import path directly to the type.
func (x {{.config.EnumID}}) Path() string {
  if str, ok := _{{.config.EnumID}}Paths[x]; ok {
    return str
  }

  return _{{.config.EnumID}}Paths[{{.config.EnumID}}(0)]
}

// PackageName returns the name of the parent package for this type.
func (x {{.config.EnumID}}) PackageName() string {
	return _{{.config.EnumID}}PkgName
}

{{- if ne .config.Go.PackagePath "" }}
// ImportPath returns the full import path of the parent package
func (x {{.config.EnumID}}) ImportPath() string {
	return _{{.config.EnumID}}PkgPath
}
{{- end}}


{{- if .config.Plugins.Namespace }}
// Namespace implements the emitter.Namespaced interface.
func (x {{.config.EnumID}}) Namespace() string {
  return _{{.config.EnumID}}Namespace
}
{{- end}}

{{- if .config.Plugins.Description }}
var _{{.config.EnumID}}Descriptions = {{ mapify_descriptions .config }}

// Description implements the emitter.Detailed interface.
func (x {{.config.EnumID}}) Description() string {
  if str, ok := _{{.config.EnumID}}Descriptions[x]; ok {
    return str
  }

	return _{{.config.EnumID}}Descriptions[{{.config.EnumID}}(0)]
}
{{end}}

{{- if .config.Plugins.Codes.YARPC }}
var _{{.config.EnumID}}YARPCCodes = {{ mapify_yarpc_codes .config }}

// ToYARPC implements the emitter.YARPCResponder interface.
func (x {{.config.EnumID}}) ToYARPC() yarpcerrors.Code {
  if c, ok := _{{.config.EnumID}}YARPCCodes[x]; ok {
    return c
  }

  return yarpcerrors.CodeUnknown
}

// YARPCError implements the yarpcerrors.IsStatus() interface.
func (x {{.config.EnumID}}) YARPCError() *yarpcerrors.Status {
	return yarpcerrors.Newf(x.ToYARPC(), x.Error())
}
{{- end }}

{{ if .config.Plugins.Codes.HTTP }}
var _{{.config.EnumID}}HTTPCodes = {{ mapify_http_codes .config }}

// ToHTTP implements the emitter.HTTPResponder interface.
func (x {{.config.EnumID}}) ToHTTP() int {
  if c, ok := _{{.config.EnumID}}HTTPCodes[x]; ok {
    return c
  }

  return 520
}
{{- end }}

{{ if .config.Plugins.Codes.OSExit }}
var _{{.config.EnumID}}OSExitCodes = {{ mapify_os_exit_codes .config }}

// ToHTTP implements the emitter.HTTPResponder interface.
func (x {{.config.EnumID}}) ToOSExit() int {
  if c, ok := _{{.config.EnumID}}OSExitCodes[x]; ok {
    return c
  }

  return 1
}
{{- end }}

{{- if .config.Plugins.Error }}
var _{{.config.EnumID}}Messages = {{ mapify_messages .config }}

// Message returns the enum short message description.
func (x {{.config.EnumID}}) Message() string {
	if str, ok := _{{.config.EnumID}}Messages[x]; ok {
		return str
	}

	return _{{.config.EnumID}}Messages[{{.config.EnumID}}(0)]
}

var _{{.config.EnumID}}Errors = {{ mapify_error_messages .config }}

// Error implements the error interface.
func (x {{.config.EnumID}}) Error() string {
	if str, ok := _{{.config.EnumID}}Errors[x]; ok {
		return str
	}

	return _{{.config.EnumID}}Errors[{{.config.EnumID}}(0)]
}
{{- end}}
{{end}}
