{{- define "header"}}
// Code generated by renum (github.com/gen0cide/renum)
// DO NOT EDIT!

package {{.package}}

import (
    "fmt"
)
{{end -}}

{{- define "definition"}}
// {{.config.EnumID}} is a generated type alias for the {{.config.EnumID}} enum.
type {{.config.EnumID}} {{.config.Go.Type}}
{{- end }}

{{- define "enum"}}
const (
{{- $enumName := .config.EnumID -}}
{{- $vars := dict "lastoffset" 0 -}}
{{ range $rIndex, $value := .config.Values }}
	{{- $lastOffset := pluck "lastoffset" $vars | first }}{{ $offset := sub $value.Value $rIndex }}
	{{ if eq $value.Pascal "_"}}// Skipped value{{else}}// {{$value.PrefixedPascal}} is an enum value for type {{$enumName}}.{{end}}
	// {{$value.Comment}}
	{{- if $value.Description}}
	// {{$value.Description}}
	{{- end}}
  {{$value.PrefixedPascal}} {{ if eq $rIndex 0 }}{{$enumName}} = iota{{ if ne 0 $offset }} + {{ $offset }}{{end}}{{else if ne $lastOffset $offset }}{{$enumName}} = iota + {{ $offset }}{{end}}{{$_ := set $vars "lastoffset" $offset}}

{{ end}}
  {{ if .config.Plugins.Namespace.Enabled }}
  _{{.config.EnumID}}Namespace = `{{.config.Plugins.Namespace.Namespace}}`
  {{- end }}
	_{{.config.EnumID}}PkgName = `{{.config.Go.PackageName}}`
	_{{.config.EnumID}}PkgPath = `{{.config.Go.PackagePath}}`
)

{{ template "stringer" . }}

// Parse{{.config.EnumID}} attempts to convert a string to a {{.config.EnumID}}
func Parse{{.config.EnumID}}(name string) ({{.config.EnumID}}, error) {
	if x, ok := _{{.config.EnumID}}Value[name]; ok {
		return x, nil
	}
	{{if .names -}}
	return {{.config.EnumID}}(0), fmt.Errorf("%s is not a valid {{.config.EnumID}}, try [%s]", name, strings.Join(_{{.config.EnumID}}Names, ", "))
	{{- else -}}
	return {{.config.EnumID}}(0), fmt.Errorf("%s is not a valid {{.config.EnumID}}", name)
	{{- end}}
}

{{ if .config.Plugins.Text }}
// MarshalText implements the text marshaller method
func (x *{{.config.EnumID}}) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *{{.config.EnumID}}) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := Parse{{.config.EnumID}}(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
{{end}}

{{ if .config.Plugins.SQL }}
// Scan implements the Scanner interface.
func (x *{{.config.EnumID}}) Scan(value interface{}) error {
	var name string

	switch v := value.(type) {
	case string:
		name = v
	case []byte:
		name = string(v)
	case nil:
		*x = {{.config.EnumID}}(0)
		return nil
	}

	tmp, err := Parse{{.config.EnumID}}(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// Value implements the driver Valuer interface.
func (x {{.config.EnumID}}) Value() (driver.Value, error) {
	return x.String(), nil
}
{{end}}

{{ if .config.Plugins.Flags }}
// Set implements the Golang flag.Value interface func.
func (x *{{.config.EnumID}}) Set(val string) error {
	v, err := Parse{{.config.EnumID}}(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *{{.config.EnumID}}) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *{{.config.EnumID}}) Type() string {
	return "{{.config.EnumID}}"
}
{{end}}

{{ if .config.Plugins.Codes.Simple }}
// Lookup{{.config.EnumID}} attempts to convert a {{.config.Go.Type}} to it's equivelent {{.config.EnumID}} value.
func Lookup{{.config.EnumID}}(id {{.config.Go.Type}}) ({{.config.EnumID}}, error) {
	if _, ok := _{{.config.EnumID}}Map[{{.config.EnumID}}(id)]; ok {
		return {{.config.EnumID}}(id), nil
	}
	{{if .names -}}
	return {{.config.EnumID}}(0), fmt.Errorf("%T(%v) is not a valid {{.config.EnumID}}, try [%s]", id, id, strings.Join(_{{.config.EnumID}}Names, ", "))
	{{- else -}}
	return {{.config.EnumID}}(0), fmt.Errorf("%T(%v) is not a valid {{.config.EnumID}}", id, id)
	{{- end}}
}

// Code implements the Coder interface.
func (x {{.config.EnumID}}) Code() int {
  return int(x)
}
{{end}}

{{ if .config.Plugins.JSON }}
// MarshalJSON implements the json.Marshaler interface.
func (x *{{.config.EnumID}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (x *{{.config.EnumID}}) UnmarshalJSON(b []byte) error {
	var s string
  if err := json.Unmarshal(b, &s); err != nil {
    return fmt.Errorf("error unmarshaling JSON value: %v", err)
  }
	tmp, err := Parse{{.config.EnumID}}(s)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
{{end}}

{{ if .config.Plugins.YAML }}
// MarshalYAML implements the yaml.Marshaler interface.
func (x *{{.config.EnumID}}) MarshalYAML() (interface{}, error) {
	return x.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface.
func (x *{{.config.EnumID}}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
  if err := unmarshal(&s); err != nil {
    return fmt.Errorf("error unmarshaling YAML value: %v", err)
  }

	tmp, err := Parse{{.config.EnumID}}(s)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
{{end}}
{{end}}


{{- define "stringer"}}
const _{{.config.EnumID}}Name = "{{ underscore_stringify .config }}"

{{- if .config.Plugins.Pascal }}
const _{{.config.EnumID}}Titles = "{{ pascalize_stringify .config }}"
{{- end }}

{{ if .names }}var _{{.config.EnumID}}Names = {{namify .config}}

// {{.config.EnumID}}Names returns a list of possible string values of {{.config.EnumID}}.
func {{.config.EnumID}}Names() []string {
	tmp := make([]string, len(_{{.config.EnumID}}Names))
	copy(tmp, _{{.config.EnumID}}Names)
	return tmp
}
{{ end -}}

var _{{.config.EnumID}}Map = {{ mapify .config }}

// String implements the Stringer interface.
func (x {{.config.EnumID}}) String() string {
	if str, ok := _{{.config.EnumID}}Map[x]; ok {
		return str
	}
	return fmt.Sprintf("{{.config.EnumID}}(%d)", x)
}

var _{{.config.EnumID}}Kinds = {{ mapify_kinds .config }}

// Kind returns a string of the Go type for the given message.
func (x {{.config.EnumID}}) Kind() string {
  if str, ok := _{{.config.EnumID}}Kinds[x]; ok {
    return str
  }

  {{if .unknown }}
  if str, ok := _{{.config.EnumID}}Kinds[{{.config.EnumID}}Unknown]; ok {
    return str
  }
  {{end}}

  return fmt.Sprintf("{{.config.EnumID}}(%d)", x)
}

var _{{.config.EnumID}}Sources = {{ mapify_full_kinds .config }}

// Source returns an import path directly to the type.
func (x {{.config.EnumID}}) Source() string {
  if str, ok := _{{.config.EnumID}}Sources[x]; ok {
    return str
  }

  {{if .unknown }}
  if str, ok := _{{.config.EnumID}}Sources[{{.config.EnumID}}Unknown]; ok {
    return str
  }
  {{end}}

  return fmt.Sprintf("{{.config.EnumID}}(%d)", x)
}

var _{{.config.EnumID}}Paths = {{ mapify_full_paths .config }}

// Source returns an import path directly to the type.
func (x {{.config.EnumID}}) Path() string {
  if str, ok := _{{.config.EnumID}}Paths[x]; ok {
    return str
  }

  {{if .unknown }}
  if str, ok := _{{.config.EnumID}}Paths[{{.config.EnumID}}Unknown]; ok {
    return str
  }
  {{end}}

  return fmt.Sprintf("{{.config.Plugins.Namespace.Namespace}}.{{.config.Go.Prefix.Snake }}_out_of_bounds_enum_%d", x)
}

// PackageName returns the name of the parent package for this type.
func (x {{.config.EnumID}}) PackageName() string {
	return _{{.config.EnumID}}PkgName
}

{{- if ne .config.Go.PackagePath "" }}
// ImportPath returns the full import path of the parent package
func (x {{.config.EnumID}}) ImportPath() string {
	return _{{.config.EnumID}}PkgPath
}
{{- end}}


{{- if .config.Plugins.Namespace }}
// Namespace implements the emitter.Namespaced interface.
func (x {{.config.EnumID}}) Namespace() string {
  return _{{.config.EnumID}}Namespace
}
{{- end}}

var _{{.config.EnumID}}Value = {{ unmapify .config .lowercase }}

{{- if .config.Plugins.Description }}
var _{{.config.EnumID}}Descriptions = {{ mapify_descriptions .config }}

// Description implements the emitter.Detailed interface.
func (x {{.config.EnumID}}) Description() string {
  if str, ok := _{{.config.EnumID}}Descriptions[x]; ok {
    return str
  }

  {{if .unknown }}
  if str, ok := _{{.config.EnumID}}Descriptions[{{.config.EnumID}}Unknown]; ok {
    return str
  }
  {{end}}

  return fmt.Sprintf("{{.config.EnumID}}(%d)", x)
}
{{end}}

{{- if .config.Plugins.Codes.YARPC }}
var _{{.config.EnumID}}YARPCCodes = {{ mapify_yarpc_codes .config }}

// ToYARPC implements the emitter.YARPCResponder interface.
func (x {{.config.EnumID}}) ToYARPC() yarpcerrors.Code {
  if c, ok := _{{.config.EnumID}}YARPCCodes[x]; ok {
    return c
  }

  return yarpcerrors.CodeUnknown
}
{{- end }}

{{ if .config.Plugins.Codes.HTTP }}
var _{{.config.EnumID}}HTTPCodes = {{ mapify_http_codes .config }}

// ToHTTP implements the emitter.HTTPResponder interface.
func (x {{.config.EnumID}}) ToHTTP() int {
  if c, ok := _{{.config.EnumID}}HTTPCodes[x]; ok {
    return c
  }

  return 520
}
{{- end }}

{{ if .config.Plugins.Codes.OSExit }}
var _{{.config.EnumID}}OSExitCodes = {{ mapify_os_exit_codes .config }}

// ToHTTP implements the emitter.HTTPResponder interface.
func (x {{.config.EnumID}}) ToOSExit() int {
  if c, ok := _{{.config.EnumID}}OSExitCodes[x]; ok {
    return c
  }

  return 1
}
{{- end }}

{{- if .config.Plugins.Error }}
var _{{.config.EnumID}}Messages = {{ mapify_messages .config }}

// Message returns the enum short message description.
func (x {{.config.EnumID}}) Message() string {
	if str, ok := _{{.config.EnumID}}Messages[x]; ok {
		return str
	}

	return fmt.Sprintf("no message available for enum %s", x.String())
}

var _{{.config.EnumID}}Errors = {{ mapify_error_messages .config }}

// Error implements the error interface.
func (x {{.config.EnumID}}) Error() string {
	if str, ok := _{{.config.EnumID}}Errors[x]; ok {
		return str
	}

	return fmt.Sprintf("%s.{{.config.Go.Prefix.Snake}}_%s (%d): %s", x.Namespace(), x.String(), x.Code(), x.Message())
}
{{- end}}
{{end}}
